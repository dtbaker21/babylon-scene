<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chair Viewer</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            outline: none !important;
            border: none !important;
            position: fixed;
            -webkit-overflow-scrolling: touch;
        }
        
        * {
            outline: none !important;
            border: none !important;
        }
        
        *:focus {
            outline: none !important;
            border: none !important;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: grab;
            outline: none !important;
            border: none !important;
            display: block;
        }
        
        #renderCanvas:active {
            cursor: grabbing;
        }
        
        #renderCanvas:focus {
            outline: none !important;
            border: none !important;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            disableWebGL2Support: false,
            powerPreference: "high-performance"
        });
        
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            
            // Enable anti-aliasing
            engine.setHardwareScalingLevel(1 / window.devicePixelRatio);

        //----LIGHT ORBS VISIBILITY---------------

            var showLightOrbs = false; // Set to true to show colored spheres at light positions

        //----BACKGROUND COLOR--------------------

            var backgroundColor = "#E8E7E7"; // Hex color for background and ground plane

        //----EXR ROTATION------------------------

            var exrRotationDegrees = 180; // Rotate the environment left/right (in degrees)

        //----MODEL POSITION----------------------

            var modelVerticalOffset = 0; // Adjust this to move model up (positive) or down (negative)

        //----GROUND PLANE HEIGHTS----------------

            var emissiveGroundHeight = 0; // Height of the emissive ground plane (catches SSAO)
            var shadowOnlyGroundHeight = 0.001; // Height of shadow-only plane (catches spotlight shadow)
            var blurredShadowPlaneHeight = 0.002; // Height of blurred rectangle shadow plane

        //----POINT LIGHTS SETUP------------------

            var pointLight1Intensity = 5; // Left/front light intensity
            var pointLight2Intensity = 5; // Right/back light intensity
            var pointLight3Intensity = 0; // Back light intensity

        //----CAMERA SETUP-----------------------
            
            // CAMERA VARIABLES - Easy adjustments
            var cameraDistance = 2.5;  // How far camera is from product (lower = closer)
            var cameraTargetHeight = 0.15;  // Height camera looks at (lower = product appears lower in frame)
            var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2,  Math.PI / 2, cameraDistance, BABYLON.Vector3(0,0,0), scene);
            camera.attachControl(canvas, true);
            camera.wheelPrecision = 40;
            camera.setTarget(new BABYLON.Vector3(0, cameraTargetHeight, 0));
            camera.panningSensibility = 0;
            camera.pinchDeltaPercentage=0.001;
            camera.fov = .3;
            camera.beta = 1.33;
            camera.alpha = -2;
            camera.upperRadiusLimit = 30;
            camera.lowerRadiusLimit = 1.7;


// Change these values:
camera.inertia = 0.7; // Back up from 0.5 to keep momentum
camera.speed = 2; // Increase speed for more responsive feel (default is 1)

// You can also try:
camera.useAutoRotationBehavior = false; // Make sure this isn't interfering

        //----SHADOW VARIABLES--------------------

            var shadowWidth = 0.9; // Width of shadow plane (adjust to make shadow wider/narrower)
            var shadowHeight = 1; // Height of shadow plane (adjust to make shadow longer/shorter)
            var shadowDarkness = 0; // Maximum darkness of shadow (0 = transparent, 1 = black)
            var shadowBlurAmount = 30; // Blur radius in pixels

        //----HDRI TEXTURE (EXR)------------------

            console.log("=== LOADING EXR ENVIRONMENT ===");
            
            // Load EXR as environment texture using EXRCubeTexture
            const hdrTexture = new BABYLON.EXRCubeTexture(
                "https://dl.dropbox.com/scl/fi/nsreuijac4dxclti13q5g/brown_photostudio_02_512.exr?rlkey=8x05nmzqyexnjro5hs0r7dyqr&st=evqale1r",
                scene,
                512,     // size
                false,   // noMipmap
                true,    // generateHarmonics
                false,   // gammaSpace
                true     // prefiltered
            );
            
            // Convert degrees to radians and apply rotation
            hdrTexture.rotationY = exrRotationDegrees * (Math.PI / 180);
            
            scene.environmentTexture = hdrTexture;
            scene.environmentIntensity = 0.6;
            
            console.log("EXR environment texture loaded with rotation:", exrRotationDegrees, "degrees");

        //----GROUND PLANE------------------------

            const groundPlane = BABYLON.MeshBuilder.CreateGround("ground", {height: 100, width: 100, subdivisions: 4});
            groundPlane.position.y = emissiveGroundHeight;

        //----POINT LIGHTS------------------------

            // Point light 1 - Left and slightly in front
            var pointLight1 = new BABYLON.PointLight("pointLight1", new BABYLON.Vector3(-2, 0, 1), scene);
            pointLight1.intensity = pointLight1Intensity;
            pointLight1.diffuse = new BABYLON.Color3(1, 1, 1);
            pointLight1.specular = new BABYLON.Color3(1, 1, 1);
            pointLight1.excludedMeshes.push(groundPlane); // Don't light the ground
            
            // Sphere to visualize point light 1
            var sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {diameter: 0.2}, scene);
            sphere1.position = pointLight1.position;
            sphere1.isVisible = showLightOrbs; // Control visibility with flag
            var sphere1Mat = new BABYLON.StandardMaterial("sphere1Mat", scene);
            sphere1Mat.emissiveColor = new BABYLON.Color3(1, 1, 0); // Yellow
            sphere1Mat.disableLighting = true;
            sphere1.material = sphere1Mat;
            
            // Point light 2 - Right and slightly behind
            var pointLight2 = new BABYLON.PointLight("pointLight2", new BABYLON.Vector3(1.5, 0.8, -1), scene);
            pointLight2.intensity = pointLight2Intensity;
            pointLight2.diffuse = new BABYLON.Color3(1, 1, 1);
            pointLight2.specular = new BABYLON.Color3(1, 1, 1);
            pointLight2.excludedMeshes.push(groundPlane); // Don't light the ground
            
            // Sphere to visualize point light 2
            var sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {diameter: 0.2}, scene);
            sphere2.position = pointLight2.position;
            sphere2.isVisible = showLightOrbs; // Control visibility with flag
            var sphere2Mat = new BABYLON.StandardMaterial("sphere2Mat", scene);
            sphere2Mat.emissiveColor = new BABYLON.Color3(0, 1, 1); // Cyan
            sphere2Mat.disableLighting = true;
            sphere2.material = sphere2Mat;
            
            // Point light 3 - Directly behind
            var pointLight3 = new BABYLON.PointLight("pointLight3", new BABYLON.Vector3(0, 0, 4), scene);
            pointLight3.intensity = pointLight3Intensity;
            pointLight3.diffuse = new BABYLON.Color3(1, 1, 1);
            pointLight3.specular = new BABYLON.Color3(1, 1, 1);
            pointLight3.excludedMeshes.push(groundPlane); // Don't light the ground
            
            // Sphere to visualize point light 3
            var sphere3 = BABYLON.MeshBuilder.CreateSphere("sphere3", {diameter: 0.2}, scene);
            sphere3.position = pointLight3.position;
            sphere3.isVisible = showLightOrbs; // Control visibility with flag
            var sphere3Mat = new BABYLON.StandardMaterial("sphere3Mat", scene);
            sphere3Mat.emissiveColor = new BABYLON.Color3(1, 0, 1); // Magenta
            sphere3Mat.disableLighting = true;
            sphere3.material = sphere3Mat;

        //----ANTI-ALIASING PIPELINE--------------

            var pipeline = new BABYLON.DefaultRenderingPipeline(
                "defaultPipeline",
                true, // HDR
                scene,
                [camera]
            );
            pipeline.fxaaEnabled = true; // Fast Approximate Anti-Aliasing
            pipeline.samples = 4; // MSAA samples (4x anti-aliasing)

        //----SHADOW LIGHT------------------------

            var lightShadowBlur = new BABYLON.SpotLight("spot00", new BABYLON.Vector3(0, 20, 0), new BABYLON.Vector3(0, -1, 0), 1.2, 24, scene);
            lightShadowBlur.shadowMinZ = 0;
            lightShadowBlur.shadowMaxZ = 20; 
            lightShadowBlur.excludedMeshes.push(groundPlane);
            
            // Contact hardening shadow generator
            var contactShadowGenerator = new BABYLON.ShadowGenerator(256, lightShadowBlur);
            contactShadowGenerator.useContactHardeningShadow = true;
            contactShadowGenerator.contactHardeningLightSizeUVRatio = 0.05;
            contactShadowGenerator.setDarkness(0.7);

        //----SSAO2-------------------------------

            const SSAO2 = new BABYLON.SSAO2RenderingPipeline("ssao2", scene, 1, [camera]);
            SSAO2.samples = 32;
            SSAO2.minZAspect = 0.05;
            SSAO2.radius = 0.2;
            SSAO2.totalStrength = 3;


        //----SSR----------------------------------
        const ssr = new BABYLON.SSRRenderingPipeline(
            "ssr", // The name of the pipeline
            scene, // The scene to which the pipeline belongs
            [camera], // The list of cameras to attach the pipeline to
            false, // Whether or not to use the geometry buffer renderer (default: false, use the pre-pass renderer)
            BABYLON.Constants.TEXTURETYPE_UNSIGNED_BYTE // The texture type used by the SSR effect (default: TEXTURETYPE_UNSIGNED_BYTE)
        );


            ssr.environmentTexture = hdrTexture;
            ssr.strength = 1;
            ssr.reflectionSpecularFalloffExponent = 5;
            ssr.enableAutomaticThicknessComputation = true;
            ssr.thickness = 0; // 2.5
            ssr.step = 3;
            ssr.blurDispersionStrength = 0.2;
            ssr.roughnessFactor = 0.2;

        //----CHAIR--------------------------------

            console.log("=== STARTING MODEL LOAD ===");

            // SCALE VARIABLE - adjust this to make model bigger/smaller
            var modelScale = 1;

            var couch = BABYLON.SceneLoader.ImportMesh("", "https://dl.dropbox.com/scl/fi/b1v5zu1ythfc9l5qff1jn/ASSET.glb?rlkey=ixjr7okieacixilw14v89mb6e&st=or4xvuo5", "my-file.glb", scene, function (mesh) {
                console.log("✅ MODEL LOADED");
                
                const meshConstant = scene.getMeshByName("__root__");
                
                if (!meshConstant) {
                    console.error("❌ ERROR: Could not find __root__ mesh");
                    return;
                }
                
                // Apply scale - negative X to flip horizontally
                meshConstant.scaling = new BABYLON.Vector3(-modelScale, modelScale, modelScale);
                
                // Apply vertical offset
                meshConstant.position.y = modelVerticalOffset;
                
                meshConstant.receiveShadows = true;
                
                // Add to shadow caster
                if (mesh[1]) {
                    contactShadowGenerator.addShadowCaster(mesh[1], true);
                }
                
                // Hide the floor plane that came with the model
                const floorPlane = scene.getMeshByName("Plane001_FLOOR_0");
                if (floorPlane) {
                    floorPlane.isVisible = false;
                }
                
                // RESTORE texture quality - enable filtering
                scene.materials.forEach((material) => {
                    if (material.getActiveTextures) {
                        material.getActiveTextures().forEach((texture) => {
                            texture.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
                            texture.anisotropicFilteringLevel = 16;
                        });
                    }
                });
                
                // ENABLE SSR ON MODEL MATERIALS
                // Add specular/reflectivity textures so SSR works on the model
                scene.materials.forEach((material) => {
                    // For PBR materials
                    if (material instanceof BABYLON.PBRMaterial) {
                        // If no reflectivity texture exists, create a white one for full reflectivity
                        if (!material.reflectivityTexture) {
                            material.reflectivityTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==", scene);
                        }
                    }
                    // For Standard materials
                    else if (material instanceof BABYLON.StandardMaterial) {
                        // If no specular texture exists, create a white one for full specularity
                        if (!material.specularTexture) {
                            material.specularTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==", scene);
                        }
                    }
                });
                
                console.log("✅ Model setup complete with SSR enabled");
            });

        //----BACKGROUND SETUP--------------------

            // Convert hex to Color3
            function hexToColor3(hex) {
                var r = parseInt(hex.slice(1, 3), 16) / 255;
                var g = parseInt(hex.slice(3, 5), 16) / 255;
                var b = parseInt(hex.slice(5, 7), 16) / 255;
                return new BABYLON.Color3(r, g, b);
            }

            // Apply background color (convert to linear space to match emissive ground)
            var bgColor = hexToColor3(backgroundColor);
            scene.clearColor = new BABYLON.Color4(bgColor.r, bgColor.g, bgColor.b, 1.0).toLinearSpace();

            // Shadow-only ground (catches spotlight shadow)
            var ground = BABYLON.Mesh.CreatePlane('ground', 1000, scene);
            ground.rotation.x = Math.PI / 2;
            ground.position.y = shadowOnlyGroundHeight;
            ground.material = new BABYLON.ShadowOnlyMaterial('mat', scene);
            ground.material.activeLight = lightShadowBlur;
            ground.receiveShadows = true;
            
            // Exclude point lights from shadow-only ground
            pointLight1.excludedMeshes.push(ground);
            pointLight2.excludedMeshes.push(ground);
            pointLight3.excludedMeshes.push(ground);

            // Emissive ground plane (catches SSAO, matches background)
            var myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            myMaterial.emissiveColor = hexToColor3(backgroundColor);
            myMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No reflections on ground
            groundPlane.material = myMaterial;

        //----BAKED AO SHADOW PLANE---------------

            // Create shadow plane (blurred rectangle) with adjustable width and height
            var shadowPlane = BABYLON.MeshBuilder.CreatePlane('shadowPlane', {width: shadowWidth, height: shadowHeight}, scene);
            shadowPlane.rotation.x = Math.PI / 2;
            shadowPlane.position.y = blurredShadowPlaneHeight;
            
            // Exclude point lights from shadow plane
            pointLight1.excludedMeshes.push(shadowPlane);
            pointLight2.excludedMeshes.push(shadowPlane);
            pointLight3.excludedMeshes.push(shadowPlane);
            
            // Create dynamic texture for baked AO shadow
            var shadowTexture = new BABYLON.DynamicTexture("shadowTexture", 2048, scene, true);
            var ctx = shadowTexture.getContext();
            
            var size = 2048;
            var centerX = size / 2;
            var centerY = size / 2;
            
            // Calculate rectangle dimensions based on aspect ratio
            var aspectRatio = shadowWidth / shadowHeight;
            var squareWidth, squareHeight;
            
            if (aspectRatio >= 1) {
                // Wider than tall
                squareWidth = size * 0.4;
                squareHeight = squareWidth / aspectRatio;
            } else {
                // Taller than wide
                squareHeight = size * 0.4;
                squareWidth = squareHeight * aspectRatio;
            }
            
            // Draw a solid rectangle first
            ctx.fillStyle = 'rgba(0, 0, 0, ' + shadowDarkness + ')';
            ctx.fillRect(
                centerX - squareWidth / 2,
                centerY - squareHeight / 2,
                squareWidth,
                squareHeight
            );
            
            // Apply canvas blur filter
            ctx.filter = 'blur(' + shadowBlurAmount + 'px)';
            
            // Redraw to apply the blur
            var tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            var tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(ctx.canvas, 0, 0);
            
            ctx.clearRect(0, 0, size, size);
            ctx.filter = 'blur(' + shadowBlurAmount + 'px)';
            ctx.drawImage(tempCanvas, 0, 0);
            
            shadowTexture.update();
            
            // Material with alpha blending
            var shadowMaterial = new BABYLON.StandardMaterial("shadowMat", scene);
            shadowMaterial.diffuseTexture = shadowTexture;
            shadowMaterial.diffuseTexture.hasAlpha = true;
            shadowMaterial.useAlphaFromDiffuseTexture = true;
            shadowMaterial.backFaceCulling = true; // Only visible from above
            shadowMaterial.disableLighting = true;
            shadowMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
            shadowMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No reflections on shadow plane
            shadowPlane.material = shadowMaterial;

            return scene;
        };
        
        const scene = createScene();
        
        engine.runRenderLoop(function () {
            scene.render();
        });
        
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
